<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
</head>
<body>
    <script>
    // JPS commit comment
    var config = {
        type: Phaser.AUTO,
        width: 1152,
        height: 648,
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 1000 },
                //debug: true
            }
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        },
        pixelArt: true,
        roundPixels: true
    };

    var game = new Phaser.Game(config);
    
    var soccerBall;
    var cursors;
    var keys;
    var playerFacing;
    var playerOne;
    var facingLeft;
    var facingRight;
    var leftGoal;
    var rightGoal;

    var currTime = 0;
    var DashTime = 200;

    function preload ()
    {
        this.load.image('BlueRight', 'Sprites/Soccer_Blue-1.png');
        this.load.image('BlueLeft', 'Sprites/Soccer_Blue-2.png');
        this.load.image('SoccerBall', 'Sprites/Soccer_Ball-1.png');
        this.load.image('Background', 'Sprites/Background.png');
        this.load.image('RightGoal', 'Sprites/Right_Goal.png');
        this.load.image('LeftGoal', 'Sprites/Left_Goal.png');
        
    }

    function create ()
    {
        let background = this.add.image(1152 / 2, 648 / 2, 'Background');
        background.setScale(.6);

        

        playerOne = new Player(900, 100, this, 1);
        playerTwo = new Player(100, 100, this, 2);
        soccerBall = new Ball(550, 0, this);
        leftGoal = new Goal(22, 600, 'LeftGoal', this);
        rightGoal = new Goal(config.width - 22, 600, 'RightGoal', this);
        walls = [];
       


        //Ball collsion with player one
        this.physics.add.collider(playerOne.getSprite(), soccerBall.getSprite(), function(player, ball) {}, function(player, ball) {calculateCollision(playerOne, soccerBall, 1, this); return false;}, this);

        //Ball collision with player two
        this.physics.add.collider(playerTwo.getSprite(), soccerBall.getSprite(), function(player, ball) {}, function(player, ball) {calculateCollision(playerTwo, soccerBall, 2, this); return false;}, this);
        
        //Ball collision with the goals
        this.physics.add.collider(leftGoal.getSprite(), soccerBall.getSprite(), function(goal, ball) {}, function(goal, ball) {
            //Score Code
            if(Math.abs(soccerBall.getX() - leftGoal.getX()) < 10){
                ball.setX(550);
                ball.setY(0);
                ball.setVelocityX(0);
                ball.setVelocityY(0);
                playerTwo.increaseScore();
            }
            return false; //Return false to override the default collision code so that the ball does not bounce off the goals
        }, this);

        this.physics.add.collider(rightGoal.getSprite(), soccerBall.getSprite(), function(goal, ball) {}, function(goal, ball) {
            //Score Code
            if(Math.abs(soccerBall.getX() - rightGoal.getX()) < 10){
                ball.setX(550);
                ball.setY(0);
                ball.setVelocityX(0);
                ball.setVelocityY(0);
                playerOne.increaseScore();
            }
            
            return false; //Return false to override the default collision code so that the ball does not bounce off the goals     
        }, this);

        //Add collision between the ball and the walls and the player and the walls
        for(i = 0; i < walls.length; i++){
            this.physics.add.collider(playerOne.getSprite(), walls[i].getSprite());
            this.physics.add.collider(playerTwo.getSprite(), walls[i].getSprite());
            this.physics.add.collider(soccerBall.getSprite(), walls[i].getSprite());
        }
            
        cursors = this.input.keyboard.createCursorKeys();
        keys = this.input.keyboard.addKeys('W, A, S, D');
    }

 
    //Calculates the collsion with the player and the ball
    function calculateCollision(player, ball, playerNum, scene) {
        let currentTime = scene.time.now;
        // Check if enough time has passed since the last kick
        if (currentTime - player.getLastKickTime() < 200) {
            // If not, return immediately without kicking
            return;
        }

        //Kick code 
        if (playerNum === 1 && cursors.left.isDown && ball.getX() - player.getX() <= 0 || playerNum === 2 && keys.A.isDown && ball.getX() - player.getX() <= 0 === true) {
            ball.setVelocityX(-90 -(Math.abs(player.getVelocityX())));
            player.setLastKickTime(currentTime);
        } else if (playerNum === 1 && cursors.right.isDown && ball.getX() - player.getX() > 0 || playerNum === 2 && keys.D.isDown && keys.D.isDown && ball.getX() - player.getX() > 0) {
            ball.setVelocityX(90 + (Math.abs(player.getVelocityX()))); 
            player.setLastKickTime(currentTime);
        }
        
        if (playerNum === 1 && cursors.up.isDown && cursors.left.isDown && ball.getX() - player.getX() <= 0 || playerNum === 2 && keys.W.isDown && keys.A.isDown && ball.getX() - player.getX() <= 0) {
            ball.setVelocityY(-700);
            ball.setVelocityX(- 90 - (Math.abs(player.getVelocityX())));
            player.setLastKickTime(currentTime);
        }

        else if (playerNum === 1 && cursors.up.isDown && cursors.right.isDown && ball.getX() - player.getX() <= 0 || playerNum === 2 && keys.W.isDown && keys.D.isDown && ball.getX() - player.getX() <= 0) {
            ball.setVelocityY(-700);
            ball.setVelocityX(90 + (Math.abs(player.getVelocityX())));
            player.setLastKickTime(currentTime);
        }

        if (playerNum === 1 && cursors.up.isDown || playerNum === 2 && keys.W.isDown) {
            ball.setVelocityY(-700);
        }
        
    }
    
    function update ()
    {   
        console.log("Score: " + playerOne.score + " Score: " + playerTwo.score);
        //Movment & Controls
        playerOne.update(cursors.up, cursors.left, cursors.down, cursors.right);
        playerTwo.update(keys.W, keys.A, keys.S, keys.D);
        soccerBall.update();  
        currTime = this.time.now;
    }



        
    class Player{
        constructor(x, y, scene, n){
            this.player = scene.physics.add.sprite(x, y, 'BlueRight');
            this.player.setVelocity(0, 0);
            this.player.setBounce(0, 0);
            this.player.setCollideWorldBounds(true);
            this.player.setScale(3.4);
            this.player.body.setSize(9, 24, 4.5, 12);
                                
            this.kickHitBox = scene.physics.add.sprite(this.player.x, this.player.y, null);
            this.kickHitBox.setVisible(false); // Make the hitbox invisible
            this.kickHitBox.setSize(50, 50); // Set the size of the hitbox
            this.kickHitBox.setVelocity(0, 0); // Set the velocity of the hitbox
            this.lastKickTime = 0;
            this.num = n;
            
            this.score = 0;

            this.canDash = false;
            this.startTimer = false;
            this.numOfClicks;
            this.LnumOfClicks;
            this.lastTime;
            this.counter;

        }

        
            
            
        update(up, left, down, right){
            
            
            //Slowdown when not pressing anything or pressing oposite movement
            if(left.isDown && right.isDown || !left.isDown && !right.isDown){

                if(this.player.body.blocked.down){
                    this.player.setVelocityX(this.player.body.velocity.x * .7);
                }
                else{
                    this.player.setVelocityX(this.player.body.velocity.x * .9);
                }

            } else if (left.isDown)
            {
                this.player.setTexture('BlueLeft');
                //Move slower in the air
                if(!this.player.body.blocked.down){
                    this.player.setVelocityX(this.player.body.velocity.x - 20);
                }
                else{   
                    this.player.setVelocityX(this.player.body.velocity.x - 70);    
                }                


            }
            else if (right.isDown)
            {
                this.player.setTexture('BlueRight');

                if(!this.player.body.blocked.down){
                    this.player.setVelocityX(this.player.body.velocity.x + 20);
                }
                else{   
                    this.player.setVelocityX(this.player.body.velocity.x + 70);    
                }  
            }

            //Jump
            if(up.isDown && this.player.body.blocked.down){
                this.player.setVelocityY(-500)
            }


            //Max horizontal speed
            if(Math.abs(this.player.body.velocity.x) > 500){
                this.player.setVelocityX(500 * Math.sign(this.player.body.velocity.x));
            }
            


            //Dash code

            right.on('down', function (pointer) {
                
                if (this.counter === 1) {
                    

                    if (this.numOfClicks === 0){
                        this.numOfClicks = 1;
                        this.lastTime = currTime;
                        this.canDash = true;
                        //console.log("one click!");
                    } else if (this.numOfClicks === 1 && this.canDash) {
                        //console.log("Dash!");
                        this.player.setVelocityX(15000);
                        this.numOfClicks = 0;
                        this.lastTime = 0;
                    } else if (currTime - this.lastTime > DashTime) {
                        this.numOfClicks = 0;
                    }
                    //console.log("click");
                    //console.log(numOfClicks);
                    
                }
               

                //console.log(currTime);
                this.counter++;
                
                
                
                
            }, this);
            if (currTime - this.lastTime < DashTime) {
                //console.log(canDash);
                this.canDash = true;
            } else {
                this.canDash = false;
                
            }
            

            

            if (right.isDown) {
                this.counter = 0;
                this.LnumOfClicks = 0;
            } else if (left.isDown) {
                this.counter = 0;
                this.numOfClicks = 0;
            }
            /*
            if (up.isDown) {
                counter = 0;
            }*/

            left.on('down', function (pointer) {
                
                if (this.counter === 1) {
                    

                    if (this.LnumOfClicks === 0){
                        this.LnumOfClicks = 1;
                        this.lastTime = currTime;
                        this.canDash = true;
                        //console.log("left one click!");
                    } else if (this.LnumOfClicks === 1 && this.canDash) {
                        //console.log("Dash!");
                        this.player.setVelocityX(-15000);
                        this.LnumOfClicks = 0;
                        this.lastTime = 0;
                    } else if (currTime - this.lastTime > DashTime) {
                        this.LnumOfClicks = 0;
                    }
                    //console.log("click");
                    //console.log(numOfClicks);
                    
                }
               

                //console.log(currTime);
                this.counter++;
                
                
                
                
            }, this);

            this.kickHitBox.x = this.player.x;
            this.kickHitBox.y = this.player.y;
            this.kickHitBox.setVelocityX(0);
            this.kickHitBox.setVelocityY(0);

        
        }
        
        getSprite(){
            return this.player;
        }
        
        getX(){
            return this.player.x;
        }
        
        getY(){
            return this.player.y;
        }
        
        getVelocityX(){
            return this.player.body.velocity.x;
        }
        
        getVelocityY(){
            return this.player.body.velocity.y;
        }
        
        getWidth(){
            return this.player.body.width;
        }
        
        getHeight(){
            return this.player.body.height;
        }

        getLastKickTime(){
            return this.lastKickTime;
        }

        getHeight(){
            return this.player.body.height;
        }

        getWidth(){
            return this.player.body.height;
        }

        setLastKickTime(n){
            this.lastKickTime = n;
        }

        increaseScore(){
            this.score++;
        }
        
    }
        
    class Ball{
        constructor(x, y, scene){
            this.ball = scene.physics.add.sprite(x, y, 'SoccerBall');
            this.ball.setScale(2.2);
            this.ball.setBounce(1);
            this.ball.setCollideWorldBounds(true);
            this.ball.body.setCircle(12.5);
        }
        
        update(){
            
            if(Math.abs(this.ball.body.velocity.x) > 700){
                this.ball.setVelocityX(700 * Math.sign(this.ball.body.velocity.x));
            }
            if(Math.abs(this.ball.body.velocity.y) > 700){
                this.ball.setVelocityY(700 * Math.sign(this.ball.body.velocity.y))
            }

            //Add friction to the ball
            if(this.ball.body.blocked.down){
                this.ball.setVelocityX(this.ball.body.velocity.x * .7);
                this.ball.setVelocityY(this.ball.body.velocity.y * .7);
            }
            else if(this.ball.body.blocked.left || this.ball.body.blocked.right){
                this.ball.setVelocityX(this.ball.body.velocity.x * .7);
                this.ball.setVelocityY(this.ball.body.velocity.y * .7);
            }
            else{
                //ball.setVelocityX(ball.body.velocity.x * .9);
                //ball.setVelocityY(ball.body.velocity.y * .9);
            }

            //Ball will always bounce
            if(this.ball.body.blocked.down && Math.abs(this.ball.body.velocity.y) < 400){
                this.ball.setVelocityY(-400);
            }
        }
        
        getSprite(){
            return this.ball;
        }
        
        getX(){
            return this.ball.x;
        }
        
        getY(){
            return this.ball.y;
        }
        
        getVelocityX(){
            return this.ball.body.velocity.x;
        }
        
        getVelocityY(){
            return this.ball.body.velocity.y;
        }
        
        getWidth(){
            return this.ball.body.width;
        }
        
        getHeight(){
            return this.ball.body.height;
        }
        
        setVelocityX(velX){
            this.ball.setVelocityX(velX);
        }
        
        setVelocityY(velY){
            this.ball.setVelocityY(velY);
        }

        setX(n){
            this.ball.x = n;
        }

        setY(n){
            this.ball.y = n;
        }
        
        
    }
    
    class Goal{
        constructor(x, y, sprite, scene){
            this.goal = scene.physics.add.sprite(x, y, sprite);
            this.goal.body.setAllowGravity(false);
            this.goal.setScale(1);
        }

        getSprite(){
            return this.goal;
        }

        getHeight(){
            return this.goal.body.height;
        }

        getWidth(){
            return this.goal.body.height;
        }
        
        getX(){
            return this.goal.x;
        }
        
        getY(){
            return this.goal.y;
        }
    }

    class Wall {
    constructor(x, y, width, height, color, scene) {
        // Create a graphics object
        let graphics = scene.make.graphics();

        // Draw a rectangle on the graphics object
        graphics.fillStyle(color);
        graphics.fillRect(0, 0, width, height);

        // Generate a texture from the graphics object
        let textureKey = 'wallTexture' + x + y;
        graphics.generateTexture(textureKey, width, height);

        // Create a physics object using the generated texture
        this.wall = scene.physics.add.staticImage(x, y, textureKey);
    }

    getSprite() {
        return this.wall;
    }
}

    </script>
</body>
</html>